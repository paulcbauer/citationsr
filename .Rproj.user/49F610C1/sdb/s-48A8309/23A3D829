{
    "collab_server" : "",
    "contents" : "#' Returns and saves text files without the references section.\n#'\n#' @param folder Name of folder within working directory in which the citing documents (.txt files) are located, e.g. \"Beck 1995\".\n#' @param number Number of .txt files in folder the function should be applied to. Default is \"all .txt files in folder\".\n#' @return Returns and saves text files without the references section.\n#'\n#'\n#' @examples\n#' \\dontrun{\n#'  setwd(\"C:/Users/paul/Google Drive/Research/2016_Quality_of_citations/data\")\n#'  folder <- \"Acemoglu 2001\"\n#'  delete_refs_n_heads(folder, number = 100)\n#' }\n\n\ndelete_refs_n_heads <- function(folder, number=NULL){\n\n    require(stringr)\n    require(xtable)\n    require(dplyr)\n\n\n# Get medadatafile for folder/study\n  load(\"./metadata.RData\") # load RData file\n\n# Identify and delete any \"processed.txt\" files present in folder\n  file.names <- dir(paste(\"./\", folder, sep = \"\"), pattern = \"processed.txt\")\n  if(identical(file.names, character(0))==FALSE){\n    file.paths <- paste(paste(\"./\", folder,\"/\", sep = \"\"), file.names, sep=\"\")\n    file.remove(file.paths)\n  }\n\n\n# List file names in folder (ONLY .TXT FILES)\n    file.names <- dir(paste(\"./\", folder, sep = \"\"), pattern = \".txt\")\n\n# Generate file paths\n    file.paths <- paste(paste(\"./\", folder, \"/\", sep = \"\"), file.names, sep=\"\")\n\n# Count number of files in folder\n    n.docs <- length(file.paths)\n\n# Specify number of documents to assess by setting n.docs\n    if(!is.null(number)){n.docs <- number}\n    if(!is.null(number)&&number>length(file.paths)){n.docs <- length(file.paths)} # if not enough files\n\n# Create empty data frame to collect potential deleted running heads\n    deleted.runningheads <- data.frame(study= NA, running.head = NA, loop.i = NA)\n\n\n\n\n# Loop over .txt files one by one (until document nr. \"number\" = n.docs)\n  for (i in 1:n.docs){\n\n    print(i)\n\n    con <- file(file.paths[i], encoding = \"UTF-8\")\n    x <- readLines(con, warn = F)\n    close(con)\n\n  # Delete empty lines in text files\n    x <- x[nzchar(x)]\n\n\n##################\n### REPLACE \\f ###\n##################\n    # print(x[stringr::str_detect(x, \"^\\f\")])\n    x <- stringr::str_replace_all(x, \"^\\f\", \"\")\n\n################################\n### DELETE REFERENCE SECTION ###\n################################\n\n    # Locate \"References\" section\n      references.location <- grep(\"^References$|^REFERENCES$|^Literatur$|^LITERATUR$|^References and Notes$\", x, ignore.case = FALSE)\n\n      if(length(references.location)==1){\n        # cat(\"In document '\", file.names[i], \"' 'References' only appears once. (discarded).\\n\\n\", sep=\"\")\n        x <- x[1:references.location]\n        }\n\n      if(length(references.location)>1){\n        cat(\"References: In '\", substr(file.names[i], 1, 30), \"...' 'searchterms' appear more than once (Using LAST LOCATION).\\n\\n\", sep=\"\")\n        x <- x[1:tail(references.location, n=1)]\n        }\n\n      if(length(references.location)<1){\n        cat(\"References: In '\", substr(file.names[i], 1, 30), \"...' 'searchterms' do not appear at all (NOT discarded).\\n\\n\", sep=\"\")\n        }\n\n\n\n\n\n\n\n\n############################\n### DELETE RUNNING HEADS ###\n############################\n\n    # Identify running titles\n    # Short length is one characteristic\n    # Repetition is one characteristic\n\n    # Store deleted running heads here for check later on\n    collect.deleted <- NULL\n\n\n    # DOWNLOADED FROM, BY ETC.\n      # print(\"downloaded from\")\n      locations <- NULL\n      pattern <- \"Downloaded by|Downloaded from|All use subject to JSTOR Terms and Conditions\"\n      locations <- grep(pattern, x, ignore.case = TRUE)\n      if(length(locations)!=0){\n        locations.names <- grep(pattern, x, ignore.case = TRUE, value = T)\n        if(length(locations.names)>=5){x <- x[-locations]}\n        collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER DOWNLOADED FROM) \", locations.names, sep=\"\"))\n      }\n\n\n    # COPYRIGHT MESSAGES\n      # print(\"copyright\")\n      locations <- NULL\n      pattern <- paste(\"All use subject to JSTOR Terms and Conditions\",\n                       \"\\\\s[0-9]{4}\\\\sThe\\\\sAuthors\",\n                       \"\\\\w\\\\sPolitical Science Association\",\n                       \"Blackwell Publishing Ltd\",\n                       \"Â©\",\n                       \"Journal compilation\"\n                       , sep=\"|\")\n      locations <- grep(pattern, x, ignore.case = FALSE)\n      if(length(locations)!=0){\n        locations.names <- grep(pattern, x, ignore.case = FALSE, value = T)\n        if(length(locations.names)>=5){x <- x[-locations]}\n        collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER COPYRIGHT) \", locations.names, sep=\"\"))\n      }\n\n\n\n    # PUBLISHER\n      # print(\"publisher\")\n      locations <- NULL\n      if(nchar(metadata$publisher[i])>=5){\n        pattern <- metadata$publisher[i]\n        locations <- grep(pattern, x, ignore.case = TRUE)\n        locations.names <- grep(pattern, x, ignore.case = TRUE, value = T)\n        locations <- locations[duplicated(locations.names) | duplicated(locations.names, fromLast=TRUE)]\n        locations.names <- locations.names[duplicated(locations.names) | duplicated(locations.names, fromLast=TRUE)]\n        if(length(locations.names)>4){\n          x <- x[-locations]\n          collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER PUBLISHER) \", locations.names, sep=\"\"))\n        }\n      }\n\n\n    # JOURNAL\n      # print(\"journal\")\n      locations <- NULL\n      if(nchar(metadata$journal[i])>=5){\n        pattern <- metadata$journal[i]\n        locations <- grep(pattern, x, ignore.case = TRUE)\n        locations.names <- grep(pattern, x, ignore.case = TRUE, value = T)\n        locations <- locations[duplicated(locations.names) | duplicated(locations.names, fromLast=TRUE)]\n        locations.names <- locations.names[duplicated(locations.names) | duplicated(locations.names, fromLast=TRUE)]\n        if(length(locations.names)>4){\n        x <- x[-locations]\n        collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER JOURNAL) \", locations.names, sep=\"\"))\n        }\n        }\n\n\n    # TITLE\n      # print(\"title\")\n      locations <- NULL\n      if(nchar(metadata$title[i])>=5){\n        pattern <- stringr::str_extract(metadata$title[i], \"^\\\\s*[:word:]*\\\\s*[:word:]*[-]*[:word:]*\\\\s*[:word:]*[-]*[:word:]*\\\\s*[:word:]*[-]*[:word:]*\\\\s*[:word:]*[-]*[:word:]*\\\\s*[:word:]*[-]*[:word:]*\")\n        locations <- grep(pattern, x, ignore.case = TRUE)\n        locations.names <- grep(pattern, x, ignore.case = TRUE, value = T)\n        locations <- locations[duplicated(locations.names) | duplicated(locations.names, fromLast=TRUE)]\n        locations.names <- locations.names[duplicated(locations.names) | duplicated(locations.names, fromLast=TRUE)]\n        if(length(locations.names)>4){\n          x <- x[-locations]\n          collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER TITLE) \", locations.names, sep=\"\"))\n        }\n      }\n\n\n\n\n    # PAGES\n      # print(\"pages\")\n      locations <- NULL\n      if(nchar(metadata$page[i])>=3){\n      pattern <- metadata$page[i]\n      locations <- grep(pattern, x, ignore.case = TRUE)\n      locations.names <- grep(pattern, x, ignore.case = TRUE, value = T)\n      locations <- locations[duplicated(locations.names) | duplicated(locations.names, fromLast=TRUE)]\n      locations.names <- locations.names[duplicated(locations.names) | duplicated(locations.names, fromLast=TRUE)]\n      if(length(locations.names)>4){\n        x <- x[-locations]\n        collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER PAGES) \", locations.names, sep=\"\"))\n      }\n      }\n\n        # pages <- c(\"615-633\", \"iii12-iii80\", NA, \"155\")\n        # for(i in 1:579){print(stringr::str_detect(metadata$page[i], \".*-.*\"))}\n\n      # IDENTIFY SINGLE PAGES - BEWARE ALSO MATCHES TABLE VALUES..\n      # print(\"single pages\")\n      if(!is.na(metadata$page[i])){\n        locations <- NULL\n        pages <- metadata$page[i]\n        pages <- str_replace_na(pages, replacement = \"NA\")\n        if(stringr::str_detect(pages, \"[0-9]+-[0-9]+\")){\n        pages <- gsub(\"[A-z]\",\"\",pages)\n        min <- as.numeric(gsub(\"-.*\",\"\",pages))\n        max <- as.numeric(gsub(\".*-\",\"\",pages))\n        if(min>max){ # REPAIR THIS IN THE METADATA\n        max2 <- max\n        max <- min\n        min <- max2\n        }\n        # print(min); print(max); print(pages); print(i)\n        pages <- seq(min, max, 1)\n        pattern <- paste(\"^\", pages, \"$\", sep=\"\")\n        pattern <- paste(pattern, collapse=\"|\")\n        locations <- stringr::str_detect(x, pattern)\n        if(length(locations)>6){\n          delnames <- x[locations]\n          x <- x[!locations]\n          collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER PAGES SINGLE) \", delnames, sep=\"\"))\n        }\n        }\n        }\n\n\n\n\n    # VOLUME, ISSUE, NUMBER\n    # print(\"volume\")\n    if(!is.na(metadata$volume[i])){\n      if(!is.na(metadata$volume[i])){volume.match <- paste(\"Volume\\\\s\", metadata$volume[i], sep=\"\")}\n      if(!is.na(metadata$issue[i])){volume.match <- paste(volume.match, paste(\"Issue\\\\s\", metadata$issue[i], sep=\"\"), sep=\"|\")}\n      pattern <- volume.match\n      locations <- grep(pattern, x, ignore.case = FALSE)\n      if(length(locations)!=0){\n        locations.names <- grep(pattern, x, ignore.case = FALSE, value = T)\n        if(length(locations.names)>=5){x <- x[-locations]\n        collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER VOLUME-ISSUE-NUMBER) \", locations.names, sep=\"\"))\n      }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n    # DATES\n    # print(\"dates\")\n    pattern <- \"(January|February|March|April|May|June|July|August|September|October|November|December)\\\\s[0-9][0-9][0-9][0-9]\\\\s/\\\\s[0-9][0-9][0-9]\"\n    # substr(metadata$date1[i], 1,4)\n    locations <- grep(pattern, x, ignore.case = FALSE)\n    if(length(locations)!=0){\n      locations.names <- grep(pattern, x, ignore.case = FALSE, value = T)\n      if(length(locations.names)>=5){x <- x[-locations]\n      #print(locations.names)\n      } # delete, print lines\n      collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER DATES) \", locations.names, sep=\"\"))\n    }\n\n\n\n\n    # AUTHORSNAMES - takes only first one\n      # print(\"authors\")\n      locations <- NULL\n      if(is.null(unlist(metadata$author[i]))){metadata$author[i] <- NA}\n\n      if(!is.na(metadata$author[i])){\n      print(metadata$author[i][[1]]$family); print(i)\n      if(nchar(metadata$author[i][[1]]$family)>=3){\n        pattern <- paste(metadata$author[i][[1]]$family, collapse=\"|\")\n        locations <- grep(pattern, x, ignore.case = TRUE)\n        locations.names <- grep(pattern, x, ignore.case = TRUE, value = T)\n        locations <- locations[nchar(locations.names)<=45]\n        locations.names <- locations.names[nchar(locations.names)<=45]\n        if(length(locations.names)>4){\n          x <- x[-locations]\n          collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER AUTHORS) \", locations.names, sep=\"\"))\n        }\n      }\n      }\n\n    # Make table of collected running heads\n    if(length(collect.deleted)!=0){ # only if running heeads were identified\n      name <- stringr::str_extract(file.names[i], \".*[0-9]{4}\") # DEPENDENCY ON FILE NAME!\n      # paste(metadata$author[i][[1]]$family[1], metadata$doc_year[1], sep=\" \")\n      running.heads <- cbind(name, collect.deleted, i) # problem if collect.deleted is empty\n      running.heads <- data.frame(running.heads)\n      names(running.heads) <- c(\"study\",\"running.head\", \"loop.i\")\n      emptyrow <- c(NA, NA, NA)\n      deleted.runningheads <- rbind(deleted.runningheads, running.heads, emptyrow)\n      # Sort according to identifier\n      # deleted.runningheads <- dplyr::arrange(deleted.runningheads, running.head, study)\n    }\n\n\n\n\n##############################\n### DELETE SECTION HEADERS ###\n##############################\n      # print(\"section headers\")\n      locations <- NULL\n      pattern <- paste(\"^CONCLUSION$\",\n                       \"^Conclusion$\",\n                       \"^INTRODUCTION$\",\n                       \"^Introduction$\",\n                       \"^Summary and Conclusions$\",\n                       sep=\"|\")\n      locations <- grep(pattern, x, ignore.case = TRUE)\n      locations.names <- grep(pattern, x, ignore.case = TRUE, value = T)\n      locations <- locations[nchar(locations.names)<=45]\n      locations.names <- locations.names[nchar(locations.names)<=45]\n      if(length(locations.names)>4){\n        x <- x[-locations]\n        collect.deleted <- c(collect.deleted, paste(\"(IDENTFIER SECTION HEADERS) \", locations.names, sep=\"\"))\n      }\n\n\n      # print(i)\n\n    # Save text\n    fileConn<-file(sub(\".txt\", \"_processed.txt\", file.paths[i]))\n    writeLines(x, fileConn, useBytes = TRUE)\n    close(fileConn)\n\n\n\n\n    # counter\n    #if(stringr::str_detect(as.character(i), \"^.*0$\")){cat(i, \".. \", sep=\"\")}\n\n  }\n\n    # Save deleted running heads in table for checking\n    print(xtable::xtable(deleted.runningheads),type='html',comment=FALSE, file=\"./deleted_running_headers.html\")\n\n    # Message to user\n    cat(\"\\n\\n\", n.docs, \" texts/documents have been stripped of references/running heads in folder '\", folder ,\"' !\\n\\n\", sep = \"\")\n\n    }\n",
    "created" : 1463429501824.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2417501341",
    "id" : "23A3D829",
    "lastKnownWriteTime" : 1463433813,
    "last_content_update" : 1463433813992,
    "path" : "C:/Users/Paul/GDrive/Packages/citations/R/delete_refs_n_heads.R",
    "project_path" : "R/delete_refs_n_heads.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}